// Copyright 2024-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.js,ts_nocheck=false"
// @generated from file cel/expr/eval.proto (package cel.expr, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Value } from "./value_pb.js";
import { file_cel_expr_value } from "./value_pb.js";
import type { Status } from "../../google/rpc/status_pb.js";
import { file_google_rpc_status } from "../../google/rpc/status_pb.js";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file cel/expr/eval.proto.
 */
export const file_cel_expr_eval: GenFile = /*@__PURE__*/
  fileDesc("ChNjZWwvZXhwci9ldmFsLnByb3RvEghjZWwuZXhwciKEAQoJRXZhbFN0YXRlEiMKBnZhbHVlcxgBIAMoCzITLmNlbC5leHByLkV4cHJWYWx1ZRIrCgdyZXN1bHRzGAMgAygLMhouY2VsLmV4cHIuRXZhbFN0YXRlLlJlc3VsdBolCgZSZXN1bHQSDAoEZXhwchgBIAEoAxINCgV2YWx1ZRgCIAEoAyKDAQoJRXhwclZhbHVlEiAKBXZhbHVlGAEgASgLMg8uY2VsLmV4cHIuVmFsdWVIABIjCgVlcnJvchgCIAEoCzISLmNlbC5leHByLkVycm9yU2V0SAASJwoHdW5rbm93bhgDIAEoCzIULmNlbC5leHByLlVua25vd25TZXRIAEIGCgRraW5kIi4KCEVycm9yU2V0EiIKBmVycm9ycxgBIAMoCzISLmdvb2dsZS5ycGMuU3RhdHVzIhsKClVua25vd25TZXQSDQoFZXhwcnMYASADKANCLAoMZGV2LmNlbC5leHByQglFdmFsUHJvdG9QAVoMY2VsLmRldi9leHBy+AEBYgZwcm90bzM", [file_cel_expr_value, file_google_rpc_status]);

/**
 * The state of an evaluation.
 *
 * Can represent an initial, partial, or completed state of evaluation.
 *
 * @generated from message cel.expr.EvalState
 */
export type EvalState = Message<"cel.expr.EvalState"> & {
  /**
   * The unique values referenced in this message.
   *
   * @generated from field: repeated cel.expr.ExprValue values = 1;
   */
  values: ExprValue[];

  /**
   * An ordered list of results.
   *
   * Tracks the flow of evaluation through the expression.
   * May be sparse.
   *
   * @generated from field: repeated cel.expr.EvalState.Result results = 3;
   */
  results: EvalState_Result[];
};

/**
 * Describes the message cel.expr.EvalState.
 * Use `create(EvalStateSchema)` to create a new message.
 */
export const EvalStateSchema: GenMessage<EvalState> = /*@__PURE__*/
  messageDesc(file_cel_expr_eval, 0);

/**
 * A single evaluation result.
 *
 * @generated from message cel.expr.EvalState.Result
 */
export type EvalState_Result = Message<"cel.expr.EvalState.Result"> & {
  /**
   * The id of the expression this result if for.
   *
   * @generated from field: int64 expr = 1;
   */
  expr: bigint;

  /**
   * The index in `values` of the resulting value.
   *
   * @generated from field: int64 value = 2;
   */
  value: bigint;
};

/**
 * Describes the message cel.expr.EvalState.Result.
 * Use `create(EvalState_ResultSchema)` to create a new message.
 */
export const EvalState_ResultSchema: GenMessage<EvalState_Result> = /*@__PURE__*/
  messageDesc(file_cel_expr_eval, 0, 0);

/**
 * The value of an evaluated expression.
 *
 * @generated from message cel.expr.ExprValue
 */
export type ExprValue = Message<"cel.expr.ExprValue"> & {
  /**
   * An expression can resolve to a value, error or unknown.
   *
   * @generated from oneof cel.expr.ExprValue.kind
   */
  kind: {
    /**
     * @generated from field: cel.expr.Value value = 1;
     */
    value: Value;
    case: "value";
  } | {
    /**
     * The set of errors in the critical path of evaluation.
     *
     * Only errors in the critical path are included. For example,
     * `(<error1> || true) && <error2>` will only result in `<error2>`,
     * while `<error1> || <error2>` will result in both `<error1>` and
     * `<error2>`.
     *
     * Errors cause by the presence of other errors are not included in the
     * set. For example `<error1>.foo`, `foo(<error1>)`, and `<error1> + 1` will
     * only result in `<error1>`.
     *
     * Multiple errors *might* be included when evaluation could result
     * in different errors. For example `<error1> + <error2>` and
     * `foo(<error1>, <error2>)` may result in `<error1>`, `<error2>` or both.
     * The exact subset of errors included for this case is unspecified and
     * depends on the implementation details of the evaluator.
     *
     * @generated from field: cel.expr.ErrorSet error = 2;
     */
    value: ErrorSet;
    case: "error";
  } | {
    /**
     * The set of unknowns in the critical path of evaluation.
     *
     * Unknown behaves identically to Error with regards to propagation.
     * Specifically, only unknowns in the critical path are included, unknowns
     * caused by the presence of other unknowns are not included, and multiple
     * unknowns *might* be included when evaluation could result in
     * different unknowns. For example:
     *
     *     (<unknown[1]> || true) && <unknown[2]> -> <unknown[2]>
     *     <unknown[1]> || <unknown[2]> -> <unknown[1,2]>
     *     <unknown[1]>.foo -> <unknown[1]>
     *     foo(<unknown[1]>) -> <unknown[1]>
     *     <unknown[1]> + <unknown[2]> -> <unknown[1]> or <unknown[2[>
     *
     * Unknown takes precedence over Error in cases where a `Value` can short
     * circuit the result:
     *
     *     <error> || <unknown> -> <unknown>
     *     <error> && <unknown> -> <unknown>
     *
     * Errors take precedence in all other cases:
     *
     *     <unknown> + <error> -> <error>
     *     foo(<unknown>, <error>) -> <error>
     *
     * @generated from field: cel.expr.UnknownSet unknown = 3;
     */
    value: UnknownSet;
    case: "unknown";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message cel.expr.ExprValue.
 * Use `create(ExprValueSchema)` to create a new message.
 */
export const ExprValueSchema: GenMessage<ExprValue> = /*@__PURE__*/
  messageDesc(file_cel_expr_eval, 1);

/**
 * A set of errors.
 *
 * The errors included depend on the context. See `ExprValue.error`.
 *
 * @generated from message cel.expr.ErrorSet
 */
export type ErrorSet = Message<"cel.expr.ErrorSet"> & {
  /**
   * @generated from field: repeated google.rpc.Status errors = 1;
   */
  errors: Status[];
};

/**
 * Describes the message cel.expr.ErrorSet.
 * Use `create(ErrorSetSchema)` to create a new message.
 */
export const ErrorSetSchema: GenMessage<ErrorSet> = /*@__PURE__*/
  messageDesc(file_cel_expr_eval, 2);

/**
 * A set of expressions for which the value is unknown.
 *
 * The unknowns included depend on the context. See `ExprValue.unknown`.
 *
 * @generated from message cel.expr.UnknownSet
 */
export type UnknownSet = Message<"cel.expr.UnknownSet"> & {
  /**
   * The ids of the expressions with unknown values.
   *
   * @generated from field: repeated int64 exprs = 1;
   */
  exprs: bigint[];
};

/**
 * Describes the message cel.expr.UnknownSet.
 * Use `create(UnknownSetSchema)` to create a new message.
 */
export const UnknownSetSchema: GenMessage<UnknownSet> = /*@__PURE__*/
  messageDesc(file_cel_expr_eval, 3);

