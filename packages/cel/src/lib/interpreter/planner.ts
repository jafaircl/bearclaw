import {
  EvalBinary,
  EvalUnary,
  EvalVarArgs,
  EvalZeroArity,
  Interpretable,
} from './interpretable';
/* eslint-disable no-case-declarations */
/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { isNil } from '@bearclaw/is';
import { Expr } from '@buf/google_cel-spec.bufbuild_es/cel/expr/syntax_pb.js';
import { AST, ReferenceInfo } from '../common/ast';
import { Container } from '../common/container';
import { BinaryOp, FunctionOp, Overload, UnaryOp } from '../common/functions';
import {
  CONDITIONAL_OPERATOR,
  EQUALS_OPERATOR,
  INDEX_OPERATOR,
  LOGICAL_AND_OPERATOR,
  LOGICAL_OR_OPERATOR,
  NOT_EQUALS_OPERATOR,
  OPT_INDEX_OPERATOR,
  OPT_SELECT_OPERATOR,
} from '../common/operators';
import { protoConstantToRefVal } from '../common/pb/constants';
import {
  isCallProtoExpr,
  isComprehensionProtoExpr,
  isConstantProtoExpr,
  isIdentProtoExpr,
  isListProtoExpr,
  isMapProtoExpr,
  isMessageProtoExpr,
  isSelectProtoExpr,
  unwrapCallProtoExpr,
  unwrapComprehensionProtoExpr,
  unwrapConstantProtoExpr,
  unwrapListProtoExpr,
  unwrapMapProtoExpr,
  unwrapMessageProtoExpr,
  unwrapSelectProtoExpr,
} from '../common/pb/expressions';
import { Adapter, Provider } from '../common/ref/provider';
import { Trait } from '../common/types/traits/trait';
import { Kind, Type } from '../common/types/types';
import { Attribute, AttributeFactory, Qualifier } from './attributes';
import { InterpretableDecorator } from './decorators';
import { Dispatcher } from './dispatcher';
import {
  EvalAnd,
  EvalAttr,
  EvalConst,
  EvalEq,
  EvalFold,
  EvalList,
  EvalMap,
  EvalNe,
  EvalObj,
  EvalOr,
  EvalTestOnly,
  InterpretableAttribute,
  isInterpretableAttribute,
  isInterpretableConst,
} from './interpretable';

/**
 * interpretablePlanner creates an Interpretable evaluation plan from a proto Expr value.
 */
export interface InterpretablePlanner {
  /**
   * Plan generates an Interpretable value (or error) from the input proto Expr.
   */
  plan(expr: Expr): Interpretable | Error;
}

/**
 * planner is an implementation of the interpretablePlanner interface.
 */
export class Planner implements InterpretablePlanner {
  #disp: Dispatcher;
  #provider: Provider;
  #adapter: Adapter;
  #attrFactory: AttributeFactory;
  #container: Container;
  #refMap: Map<bigint, ReferenceInfo>;
  #typeMap: Map<bigint, Type>;
  #decorators: InterpretableDecorator[];

  constructor(
    disp: Dispatcher,
    provider: Provider,
    adapter: Adapter,
    attrFactory: AttributeFactory,
    cont: Container,
    exprAst: AST,
    decorators: InterpretableDecorator[]
  ) {
    this.#disp = disp;
    this.#provider = provider;
    this.#adapter = adapter;
    this.#attrFactory = attrFactory;
    this.#container = cont;
    this.#refMap = exprAst.referenceMap();
    this.#typeMap = exprAst.typeMap();
    this.#decorators = decorators;
  }

  plan(expr: Expr): Interpretable | Error {
    switch (expr.exprKind.case) {
      case 'identExpr':
        return this.decorate(this.planIdent(expr));
      case 'selectExpr':
        return this.decorate(this.planSelect(expr));
      case 'callExpr':
        return this.decorate(this.planCall(expr));
      case 'listExpr':
        return this.decorate(this.planCreateList(expr));
      case 'structExpr':
        if (isMessageProtoExpr(expr)) {
          return this.decorate(this.planCreateStruct(expr));
        }
        return this.decorate(this.planCreateMap(expr));
      case 'comprehensionExpr':
        return this.decorate(this.planComprehension(expr));
      case 'constExpr':
        return this.decorate(this.planConst(expr));
      default:
        throw new Error('Unimplmented expression type');
    }
  }

  /**
   * decorate applies the InterpretableDecorator functions to the given
   * Interpretable. Both the Interpretable and error generated by a Plan step
   * are accepted as arguments for convenience.
   */
  decorate(i: Interpretable | Error): Interpretable | Error {
    if (i instanceof Error) {
      return i;
    }
    for (const decorator of this.#decorators) {
      const decorated = decorator(i);
      if (decorated instanceof Error) {
        return decorated;
      }
      i = decorated;
    }
    return i;
  }

  /**
   * planIdent creates an Interpretable that resolves an identifier from an Activation.
   */
  planIdent(expr: Expr): Interpretable | Error {
    if (!isIdentProtoExpr(expr)) {
      throw new Error('expected identExpr');
    }
    // Establish whether the identifier is in the reference map.
    if (this.#refMap.has(expr.id)) {
      return this.planCheckedIdent(expr.id, this.#refMap.get(expr.id)!);
    }
    // Create the possible attribute list for the unresolved reference.
    return new EvalAttr(
      this.#adapter,
      this.#attrFactory.maybeAttribute(expr.id, expr.exprKind.value.name)
    );
  }

  planCheckedIdent(id: bigint, identRef: ReferenceInfo): Interpretable | Error {
    // Plan a constant reference if this is the case for this simple identifier.
    if (!isNil(identRef.value)) {
      return new EvalConst(id, identRef.value);
    }

    // Check to see whether the type map indicates this is a type name. All
    // types should be registered with the provider.
    const cType = this.#typeMap.get(id);
    if (cType?.kind() == Kind.TYPE) {
      const cVal = this.#provider.findIdent(identRef.name!);
      if (isNil(cVal)) {
        return new Error(`reference to undefined type: ${identRef.name}`);
      }
      return new EvalConst(id, cVal);
    }

    // Otherwise, return the attribute for the resolved identifier name.
    return new EvalAttr(
      this.#adapter,
      this.#attrFactory.absoluteAttribute(id, identRef.name!)
    );
  }

  /**
   * planSelect creates an Interpretable with either:
   *
   *  - a) selects a field from a map or proto.
   *  - b) creates a field presence test for a select within a has() macro.
   *  - c) resolves the select expression to a namespaced identifier.
   */
  planSelect(expr: Expr): Interpretable | Error {
    if (!isSelectProtoExpr(expr)) {
      throw new Error('expected selectExpr');
    }
    // If the Select id appears in the reference map from the CheckedExpr proto
    // then it is either a namespaced identifier or enum value.
    if (this.#refMap.has(expr.id)) {
      return this.planCheckedIdent(expr.id, this.#refMap.get(expr.id)!);
    }

    const sel = unwrapSelectProtoExpr(expr)!;
    // Plan the operand evaluation.
    const op = this.plan(sel.operand!);
    if (op instanceof Error) {
      return op;
    }
    const opType = this.#typeMap.get(sel.operand!.id)!;

    // If the Select was marked TestOnly, this is a presence test.
    //
    // Note: presence tests are defined for structured (e.g. proto) and dynamic
    // values (map, json)
    // as follows:
    //  - True if the object field has a non-default value, e.g. obj.str != ""
    //  - True if the dynamic value has the field defined, e.g. key in map
    //
    // However, presence tests are not defined for qualified identifier names
    // with primitive types. If a string named 'a.b.c' is declared in the
    // environment and referenced within `has(a.b.c)`, it is not clear whether
    // has should error or follow the convention defined for structured values.

    // Establish the attribute reference.
    let attr = op;
    if (!isInterpretableAttribute(op)) {
      attr = this.relativeAttr(op.id(), op, false) as Interpretable;
      if (attr instanceof Error) {
        return attr;
      }
    }

    // Build a qualifier for the attribute.
    const qual = this.#attrFactory.newQualifier(
      opType,
      expr.id,
      sel.field,
      false
    );
    if (qual instanceof Error) {
      return qual;
    }
    // Modify the attribute to be test-only.
    if (sel.testOnly) {
      attr = new EvalTestOnly(expr.id, attr as InterpretableAttribute);
    }
    // Append the qualifier on the attribute.
    (attr as InterpretableAttribute).addQualifier(qual);
    return attr;
  }

  /**
   * planCall creates a callable Interpretable while specializing for common
   * functions and invocation patterns. Specifically, conditional
   * operators &&, ||, ?:, and (in)equality functions result in optimized
   * Interpretable values.
   */
  planCall(expr: Expr): Interpretable | Error {
    if (!isCallProtoExpr(expr)) {
      throw new Error('expected callExpr');
    }
    const call = unwrapCallProtoExpr(expr)!;
    const [target, fnName, oName] = this.resolveFunction(expr);
    let argCount = call.args.length;
    if (!isNil(target)) {
      argCount++;
    }

    const args: Interpretable[] = [];
    if (!isNil(target)) {
      const arg = this.plan(target);
      if (arg instanceof Error) {
        return arg;
      }
      args.push(arg);
    }
    for (let i = 0; i < call.args.length; i++) {
      const arg = this.plan(call.args[i]);
      if (arg instanceof Error) {
        return arg;
      }
      args.push(arg);
    }

    // Generate specialized Interpretable operators by function name if possible.
    switch (fnName) {
      case LOGICAL_AND_OPERATOR:
        return this.planCallLogicalAnd(expr, args);
      case LOGICAL_OR_OPERATOR:
        return this.planCallLogicalOr(expr, args);
      case CONDITIONAL_OPERATOR:
        return this.planCallConditional(expr, args);
      case EQUALS_OPERATOR:
        return this.planCallEqual(expr, args);
      case NOT_EQUALS_OPERATOR:
        return this.planCallNotEqual(expr, args);
      case INDEX_OPERATOR:
        return this.planCallIndex(expr, args, false);
      case OPT_SELECT_OPERATOR:
      case OPT_INDEX_OPERATOR:
        return this.planCallIndex(expr, args, true);
      default:
        break;
    }

    // Otherwise, generate Interpretable calls specialized by argument count.
    // Try to find the specific function by overload id.
    let fnDef: Overload | null = null;
    if (oName !== '') {
      fnDef = this.#disp.findOverload(oName);
    }
    // If the overload id couldn't resolve the function, try the simple function name.
    if (isNil(fnDef)) {
      fnDef = this.#disp.findOverload(fnName);
    }
    switch (argCount) {
      case 0:
        return this.planCallZero(expr, fnName, oName, fnDef);
      case 1:
        // If the FunctionOp has been used, then use it as it may exist for the purposes
        // of dynamic dispatch within a singleton function implementation.
        if (!isNil(fnDef) && isNil(fnDef.unary) && !isNil(fnDef.function)) {
          return this.planCallVarArgs(expr, fnName, oName, fnDef, args);
        }
        return this.planCallUnary(expr, fnName, oName, fnDef, args);
      case 2:
        // If the FunctionOp has been used, then use it as it may exist for the purposes
        // of dynamic dispatch within a singleton function implementation.
        if (!isNil(fnDef) && isNil(fnDef.binary) && !isNil(fnDef.function)) {
          return this.planCallVarArgs(expr, fnName, oName, fnDef, args);
        }
        return this.planCallBinary(expr, fnName, oName, fnDef, args);
      default:
        return this.planCallVarArgs(expr, fnName, oName, fnDef, args);
    }
  }

  /**
   * planCallZero generates a zero-arity callable Interpretable.
   */
  planCallZero(
    expr: Expr,
    _function: string,
    overload: string,
    impl: Overload | null
  ): Interpretable | Error {
    if (isNil(impl) || isNil(impl.function)) {
      return new Error(`no such overload: ${_function}()`);
    }
    return new EvalZeroArity(expr.id, _function, overload, impl.function);
  }

  /**
   * planCallUnary generates a unary callable Interpretable.
   */
  planCallUnary(
    expr: Expr,
    _function: string,
    overload: string,
    impl: Overload | null,
    args: Interpretable[]
  ): Interpretable | Error {
    let fn: UnaryOp | null = null;
    let trait = Trait.UNSPECIFIED;
    let nonStrict = true;
    if (!isNil(impl)) {
      if (isNil(impl.unary)) {
        return new Error(`no such overload: ${_function}(arg)`);
      }
      fn = impl.unary;
      trait = impl.operandTrait;
      nonStrict = impl.nonStrict ?? nonStrict;
    }
    return new EvalUnary(
      expr.id,
      _function,
      overload,
      args[0],
      trait,
      fn,
      nonStrict
    );
  }

  /**
   * planCallBinary generates a binary callable Interpretable.
   */
  planCallBinary(
    expr: Expr,
    _function: string,
    overload: string,
    impl: Overload | null,
    args: Interpretable[]
  ): Interpretable | Error {
    let fn: BinaryOp | null = null;
    let trait = Trait.UNSPECIFIED;
    let nonStrict = true;
    if (!isNil(impl)) {
      if (isNil(impl.binary)) {
        return new Error(`no such overload: ${_function}(lhs, rhs)`);
      }
      fn = impl.binary;
      trait = impl.operandTrait;
      nonStrict = impl.nonStrict ?? nonStrict;
    }
    return new EvalBinary(
      expr.id,
      _function,
      overload,
      args[0],
      args[1],
      trait,
      fn,
      nonStrict
    );
  }

  /**
   * planCallVarArgs generates a variable argument callable Interpretable.
   */
  planCallVarArgs(
    expr: Expr,
    _function: string,
    overload: string,
    impl: Overload | null,
    args: Interpretable[]
  ): Interpretable | Error {
    let fn: FunctionOp | null = null;
    let trait = Trait.UNSPECIFIED;
    let nonStrict = true;
    if (!isNil(impl)) {
      if (isNil(impl.function)) {
        return new Error(`no such overload: ${_function}(...)`);
      }
      fn = impl.function;
      trait = impl.operandTrait;
      nonStrict = impl.nonStrict ?? nonStrict;
    }
    return new EvalVarArgs(
      expr.id,
      _function,
      overload,
      args,
      trait,
      fn,
      nonStrict
    );
  }

  /**
   * planCallEqual generates an equals (==) Interpretable.
   */
  planCallEqual(expr: Expr, args: Interpretable[]): Interpretable | Error {
    return new EvalEq(expr.id, args[0], args[1]);
  }

  /**
   * planCallNotEqual generates a not equals (!=) Interpretable.
   */
  planCallNotEqual(expr: Expr, args: Interpretable[]): Interpretable | Error {
    return new EvalNe(expr.id, args[0], args[1]);
  }

  /**
   * planCallLogicalAnd generates a logical and (&&) Interpretable.
   */
  planCallLogicalAnd(expr: Expr, args: Interpretable[]): Interpretable | Error {
    return new EvalAnd(expr.id, args);
  }

  /**
   * planCallLogicalOr generates a logical or (||) Interpretable.
   */
  planCallLogicalOr(expr: Expr, args: Interpretable[]): Interpretable | Error {
    return new EvalOr(expr.id, args);
  }

  /**
   * planCallConditional generates a conditional / ternary (c ? t : f)
   * Interpretable.
   */
  planCallConditional(
    expr: Expr,
    args: Interpretable[]
  ): Interpretable | Error {
    const cond = args[0];
    const t = args[1];
    let tAttr: Attribute;
    if (isInterpretableAttribute(t)) {
      tAttr = t.attr();
    } else {
      tAttr = this.#attrFactory.relativeAttribute(t.id(), t);
    }

    const f = args[2];
    let fAttr: Attribute;
    if (isInterpretableAttribute(f)) {
      fAttr = f.attr();
    } else {
      fAttr = this.#attrFactory.relativeAttribute(f.id(), f);
    }

    return new EvalAttr(
      this.#adapter,
      this.#attrFactory.conditionalAttribute(expr.id, cond, tAttr, fAttr)
    );
  }

  /**
   * planCallIndex either extends an attribute with the argument to the index
   * operation, or creates a relative attribute based on the return of a
   * function call or operation.
   */
  planCallIndex(
    expr: Expr,
    args: Interpretable[],
    optional: boolean
  ): Interpretable | Error {
    const op = args[0];
    const ind = args[1];
    const opType = this.#typeMap.get(op.id())!;

    // Establish the attribute reference.
    let attr = op;
    if (!isInterpretableAttribute(op)) {
      attr = this.relativeAttr(op.id(), op, false) as Interpretable;
      if (attr instanceof Error) {
        return attr;
      }
    }

    // Construct the qualifier type.
    let qual: Qualifier | Interpretable | Error | null = null;
    if (isInterpretableConst(ind)) {
      qual = this.#attrFactory.newQualifier(
        opType,
        expr.id,
        ind.value(),
        optional
      );
    } else if (isInterpretableAttribute(ind)) {
      qual = this.#attrFactory.newQualifier(opType, expr.id, ind, optional);
    } else {
      qual = this.relativeAttr(expr.id, ind, optional);
    }
    if (qual instanceof Error) {
      return qual;
    }

    // Add the qualifier to the attribute
    (attr as InterpretableAttribute).addQualifier(qual as Qualifier);
    return attr;
  }

  /**
   * planCreateList generates a list construction Interpretable.
   */
  planCreateList(expr: Expr): Interpretable | Error {
    if (!isListProtoExpr(expr)) {
      throw new Error('expected listExpr');
    }
    const list = unwrapListProtoExpr(expr)!;
    const optionalIndices = list.optionalIndices;
    const elements = list.elements;
    const optionals: boolean[] = new Array(elements.length).fill(false);
    let hasOptionals = false;
    for (const index of optionalIndices) {
      if (index < 0 || index >= elements.length) {
        return new Error(
          `optional index ${index} out of element bounds [0, ${elements.length}]`
        );
      }
      optionals[index] = true;
      hasOptionals = true;
    }
    const elems: Interpretable[] = [];
    for (let i = 0; i < elements.length; i++) {
      const elemVal = this.plan(elements[i]);
      if (elemVal instanceof Error) {
        return elemVal;
      }
      elems.push(elemVal);
    }
    return new EvalList(expr.id, elems, optionals, hasOptionals, this.#adapter);
  }

  /**
   * planCreateMap generates a map or object construction Interpretable.
   */
  planCreateMap(expr: Expr): Interpretable | Error {
    if (!isMapProtoExpr(expr)) {
      throw new Error('expected structExpr (map)');
    }
    const m = unwrapMapProtoExpr(expr)!;
    const entries = m.entries;
    const optionals: boolean[] = [];
    const keys: Interpretable[] = [];
    const vals: Interpretable[] = [];
    let hasOptionals = false;
    for (let i = 0; i < entries.length; i++) {
      const entry = entries[i];
      const keyVal = this.plan(entry.keyKind.value);
      if (keyVal instanceof Error) {
        return keyVal;
      }
      keys.push(keyVal);

      if (!entry.optionalEntry && isNil(entry.value)) {
        return new Error(`required map value missing`);
      }
      // TODO: this could be an issue for maps with optional values
      const valVal = this.plan(entry.value!);
      if (valVal instanceof Error) {
        return valVal;
      }
      vals.push(valVal);
      optionals.push(entry.optionalEntry);
      hasOptionals = hasOptionals || entry.optionalEntry;
    }
    return new EvalMap(
      expr.id,
      keys,
      vals,
      optionals,
      hasOptionals,
      this.#adapter
    );
  }

  /**
   * planCreateStruct generates an object construction Interpretable.
   */
  planCreateStruct(expr: Expr): Interpretable | Error {
    if (!isMessageProtoExpr(expr)) {
      throw new Error('expected structExpr (message)');
    }
    const obj = unwrapMessageProtoExpr(expr)!;
    const typeName = this.resolveTypeName(obj.messageName);
    if (isNil(typeName)) {
      return new Error(`unknown type: ${obj.messageName}`);
    }
    const objFields = obj.entries;
    const optionals: boolean[] = [];
    const fields: string[] = [];
    const vals: Interpretable[] = [];
    let hasOptionals = false;
    for (let i = 0; i < objFields.length; i++) {
      const field = objFields[i];
      fields.push(field.keyKind.value);
      const val = this.plan(field.value!);
      if (val instanceof Error) {
        return val;
      }
      vals.push(val);
      optionals.push(field.optionalEntry);
      hasOptionals = hasOptionals || field.optionalEntry;
    }
    return new EvalObj(
      expr.id,
      typeName,
      fields,
      vals,
      optionals,
      hasOptionals,
      this.#provider
    );
  }

  /**
   * planComprehension generates an Interpretable fold operation.
   */
  planComprehension(expr: Expr): Interpretable | Error {
    if (!isComprehensionProtoExpr(expr)) {
      throw new Error('expected comprehensionExpr');
    }
    const fold = unwrapComprehensionProtoExpr(expr)!;
    const accu = this.plan(fold.accuInit!);
    if (accu instanceof Error) {
      return accu;
    }
    const iterRange = this.plan(fold.iterRange!);
    if (iterRange instanceof Error) {
      return iterRange;
    }
    const cond = this.plan(fold.loopCondition!);
    if (cond instanceof Error) {
      return cond;
    }
    const step = this.plan(fold.loopStep!);
    if (step instanceof Error) {
      return step;
    }
    const result = this.plan(fold.result!);
    if (result instanceof Error) {
      return result;
    }
    return new EvalFold(
      expr.id,
      fold.accuVar,
      fold.iterVar,
      fold.iterVar2,
      iterRange,
      accu,
      cond,
      step,
      result,
      this.#adapter,
      false,
      false
    );
  }

  /**
   * planConst generates a constant valued Interpretable.
   */
  planConst(expr: Expr): Interpretable | Error {
    if (!isConstantProtoExpr(expr)) {
      throw new Error('expected constExpr');
    }
    return new EvalConst(
      expr.id,
      protoConstantToRefVal(unwrapConstantProtoExpr(expr)!)
    );
  }

  /**
   * resolveTypeName takes a qualified string constructed at parse time,
   * applies the proto namespace resolution rules to it in a scan over possible
   * matching types in the TypeProvider.
   */
  resolveTypeName(typeName: string): string | null {
    const candidateNames = this.#container.resolveCandidateNames(typeName);
    for (const qualifiedTypeName of candidateNames) {
      const found = this.#provider.findStructType(qualifiedTypeName);
      if (!isNil(found)) {
        return qualifiedTypeName;
      }
    }
    return null;
  }

  /**
   * resolveFunction determines the call target, function name, and overload
   * name from a given Expr value.
   *
   * The resolveFunction resolves ambiguities where a function may either be a
   * receiver-style invocation or a qualified global function name.
   *
   * - The target expression may only consist of ident and select expressions.
   * - The function is declared in the environment using its fully-qualified
   * name.
   * - The fully-qualified function name matches the string serialized target
   * value.
   */
  resolveFunction(expr: Expr): [Expr | null, string, string] {
    if (!isCallProtoExpr(expr)) {
      throw new Error('expected callExpr');
    }
    // Note: similar logic exists within the `checker/checker.go`. If making
    // changes here please consider the impact on checker.go and consolidate
    // implementations or mirror code as appropriate.
    const call = unwrapCallProtoExpr(expr)!;
    let target: Expr | null = null;
    if (!isNil(call.target)) {
      target = call.target;
    }
    const fnName = call.function;

    // Checked expressions always have a reference map entry, and _should_ have
    // the fully qualified function name as the fnName value.
    const hasOverload = this.#refMap.has(expr.id);
    if (hasOverload) {
      const oRef = this.#refMap.get(expr.id)!;
      if (oRef.overloadIds?.length === 1) {
        return [target!, fnName, oRef.overloadIds[0]];
      }
      // Note, this namespaced function name will not appear as a fully
      // qualified name in ASTs built and stored before cel-go v0.5.0; however,
      // this functionality did not work at all before the v0.5.0 release.
      return [target, fnName, ''];
    }

    // Parse-only expressions need to handle the same logic as is normally
    // performed at check time, but with potentially much less information. The
    // only reliable source of information about which functions are configured
    // is the dispatcher.
    if (isNil(target)) {
      // If the user has a parse-only expression, then it should have been
      // configured as such in the interpreter dispatcher as it may have been
      // omitted from the checker environment.
      for (const qualifiedName of this.#container.resolveCandidateNames(
        fnName
      )) {
        const overload = this.#disp.findOverload(qualifiedName);
        if (!isNil(overload)) {
          return [null, qualifiedName, ''];
        }
      }
      // It's possible that the overload was not found, but this situation is
      // accounted for in the planCall phase; however, the leading dot used for
      // denoting fully-qualified namespaced identifiers must be stripped, as
      // all declarations already use fully-qualified names. This stripping
      // behavior is handled automatically by the ResolveCandidateNames call.
      return [target, stripLeadingDot(fnName), ''];
    }

    // Handle the situation where the function target actually indicates a qualified function name.
    const qualifiedPrefix = this.toQualifiedName(target);
    if (!isNil(qualifiedPrefix)) {
      const maybeQualifiedName = qualifiedPrefix + '.' + fnName;
      for (const qualifiedName of this.#container.resolveCandidateNames(
        maybeQualifiedName
      )) {
        const overload = this.#disp.findOverload(qualifiedName);
        if (!isNil(overload)) {
          // Clear the target to ensure the proper arity is used for finding the
          // implementation.
          return [null, qualifiedName, ''];
        }
      }
    }
    // In the default case, the function is exactly as it was advertised: a receiver call on with
    // an expression-based target with the given simple function name.
    return [target, fnName, ''];
  }

  /**
   * relativeAttr indicates that the attribute in this case acts as a qualifier
   * and as such needs to be observed to ensure that it's evaluation value is
   * properly recorded for state tracking.
   */
  relativeAttr(
    id: bigint,
    _eval: Interpretable,
    optional: boolean
  ): Interpretable | Error {
    let eAttr = _eval as InterpretableAttribute;
    if (!isInterpretableAttribute(_eval)) {
      eAttr = new EvalAttr(
        this.#adapter,
        this.#attrFactory.relativeAttribute(id, _eval),
        optional
      );
    }
    // This looks like it should either decorate the new evalAttr node, or early return the InterpretableAttribute
    const decAttr = this.decorate(eAttr);
    if (decAttr instanceof Error) {
      return decAttr;
    }
    eAttr = decAttr as InterpretableAttribute;
    if (!isInterpretableAttribute(decAttr)) {
      return new Error(`invalid attribute decoration: ${decAttr}(${decAttr})`);
    }
    return eAttr;
  }

  /**
   * toQualifiedName converts an expression AST into a qualified name if
   * possible, with a boolean 'found' value that indicates if the conversion is
   * successful.
   */
  toQualifiedName(operand: Expr): string | null {
    // If the checker identified the expression as an attribute by the
    // type-checker, then it can't possibly be part of qualified name in a namespace.
    if (this.#refMap.has(operand.id)) {
      return null;
    }
    // Since functions cannot be both namespaced and receiver functions, if the operand is not an
    // qualified variable name, return the (possibly) qualified name given the expressions.
    switch (operand.exprKind.case) {
      case 'identExpr':
        return operand.exprKind.value.name;
      case 'selectExpr':
        const sel = operand.exprKind.value;
        // Test only expressions are not valid as qualified names.
        if (sel.testOnly) {
          return null;
        }
        const qual = this.toQualifiedName(sel.operand!);
        if (!isNil(qual)) {
          return `${qual}.${sel.field}`;
        }
        break;
      default:
        break;
    }
    return null;
  }
}

function stripLeadingDot(name: string) {
  if (name.startsWith('.')) {
    return name.slice(1);
  }
  return name;
}
